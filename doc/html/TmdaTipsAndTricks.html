<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>TmdaTipsAndTricks</title>
<link rel="stylesheet" type="text/css" media="all" charset="utf-8" href="mentalwealth/css/common.css">
<link rel="stylesheet" type="text/css" media="screen" charset="utf-8" href="mentalwealth/css/screen.css">
<link rel="stylesheet" type="text/css" media="print" charset="utf-8" href="mentalwealth/css/print.css">
</head>
<body>
<table>
<tr>
<td>
<img src="logo.png">
</td>
<td>
&nbsp;[<a href="FrontPage.html">FrontPage</a>]&nbsp;[<a href="TitleIndex.html">TitleIndex</a>]&nbsp;[<a href="WordIndex.html">WordIndex</a>]
</td>
</tr>
</table>
<hr>
<div id="page">
<h1 id="title">TmdaTipsAndTricks</h1>
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867"><strong>TMDA Tips &amp; Tricks</strong> <span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li><a href="#head-eb2d8f2525d588f19575150079ed91810b1adbd1">Rejecting mail with non-ASCII headers (i.e, Asian spam)</a></li><li><a href="#head-6a0479eeb8eadacd1ae84a50f1e1d04f0f31c70a">List of spammer domains who "auto-confirm"</a></li><li><a href="#head-b32bec5b12ab13cf5415231203fee5b8475deb2b">Supporting the Habeas SWE headers</a></li><li><a href="#head-1166fa525e5050c978c370da72a6c5f29e4bacca">Rotating TMDA logs</a></li><li><a href="#head-02d10a9b3f486744662ad22509f12cbdc1269be2">Blocking SPAM where sender equals recipient (Exim 4.x)</a></li><li><a href="#head-954538db8b8b61ea673bf045a777d57e9e14842e">Using SMTP server instead of tmda-ofmipd for non-Unix MUAs mail sending (Exim 4.x)</a></li><li><a href="#head-8fc28dccfdc0368d450108a014e457a319afc462">How to improve performance (for high volume sites)</a></li><li><a href="#head-c6f1707b95c5e8674235e942cc5beef89533865b">X-TMDA: and Mozilla Thunderbird</a></li></ol></div><p class="line874"> <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line867">
<h2 id="head-eb2d8f2525d588f19575150079ed91810b1adbd1">Rejecting mail with non-ASCII headers (i.e, Asian spam)</h2>
<span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line874">You'll find that quite a bit of spam originating from Asian countries like Korea and Taiwan is sent with raw 8-bit data in the headers. <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line874">This is a clear violation of RFC 2821, section 2.3.1. 8-bit data in headers must be properly ASCII encoded according to RFC 2047. Thus, it's a good way to weed out some obvious spam, as properly encoded mail containing Asian character sets should not be affected by this. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line874">You can reject mail with non-ASCII data in the headers using the following FILTER_INCOMING entry: <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><p class="line867"><span class="anchor" id="line-16"></span><pre># Reject mail with non-ASCII text (byte values &gt; 127) in the Subject:
<span class="anchor" id="line-17"></span># or From: headers.
<span class="anchor" id="line-18"></span>headers '^(subject|from)\s*:.*[^\x00-\x7f]{5,}' bounce
<span class="anchor" id="line-19"></span></pre><span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line874">I've found it catches most of my .kr, .tw, and .ru spam, with 0 false positives. <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><p class="line874">This regex can also be used at the MTA level; in fact I got it from a Postfix user who using it this way. <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line867">
<h2 id="head-6a0479eeb8eadacd1ae84a50f1e1d04f0f31c70a">List of spammer domains who "auto-confirm"</h2>
<span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line874">Currently, there are no known spammers who actively try and "auto-confirm" TMDA confirmation requests, but in a roundabout way, this sometimes happens. <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line874">Sometimes non-RFC-compliant mail software returns undeliverable messages to the Reply-To address instead of the envelope sender address. When spammers forge messages from such servers, TMDA will send a confirmation request back, and the server will respond to the confirmation address in Reply-To, and the spam will be released to you. See FAQ 1.13 for some workarounds. <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line874">We are no longer providing an actual list of domains, as there are too many, and it's unfair to keep a domain listed that might have corrected their practices. <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line874">One interesting idea would be to maintain an RBL (real-time blackhole list) service listing domains who auto-confirm. This would provide a more reliable and dynamic way for TMDA users to reduce the likelihood of automated confirmations. At this point, it's probably overkill, but something to keep in mind if challenge/response starts to become more popular. <span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line867">
<h2 id="head-b32bec5b12ab13cf5415231203fee5b8475deb2b">Supporting the Habeas SWE headers</h2>
<span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line867"><a class="http" href="http://www.habeas.com/">Habeas</a> provides a creative way to "prove" that an e-mail message is NOT spam by including a copyrighted haiku poem in the headers of an outbound message. You must agree to a license agreement and acceptable use policy before you can use the Habeas SWE headers in a message, so the idea is that unauthorized users (i.e, spammers) will not use them due to fear of legal repercussions. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line874">It's not clear yet whether this strategy will be able to effectively resist abuse. Spamming is an inherently illegal activity, so abiding by U.S. copyright/trademark law may not be a concern for many spammers. Issues such as international litigation against overseas spammers and difficulty in tracking the true origin of spammers are additional impediments. <span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line874">Theoretically, it would provide a nice way for the TMDA user to reduce the number of confirmation requests he sends out to unknown correspondents. Of course, this assumes the system won't be abused, and that a large number of users adopt Habeas. <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><p class="line874">If you'd like to unconditionally accept messages that contain the Habeas SWE headers, you can can use the following entry in your FILTER_INCOMING file: <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line867"><span class="anchor" id="line-46"></span><pre># Accept mail containing the Habeas SWE headers
<span class="anchor" id="line-47"></span>headers '^X-Habeas-SWE-3.*like Habeas SWE \(tm\)' ok
<span class="anchor" id="line-48"></span></pre><span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><p class="line874">If you wish to add the Habeas SWE headers to your own outgoing messages, you can do so with ADDED_HEADERS_CLIENT and ADDED_HEADERS_SERVER entries. Make sure to fill out the Habeas license agreement first though. For example, <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><p class="line867"><span class="anchor" id="line-53"></span><pre>ADDED_HEADERS_CLIENT = {
<span class="anchor" id="line-54"></span>    # The Habeas SWE headers  
<span class="anchor" id="line-55"></span>    'X-Habeas-SWE-1' : 'winter into spring',
<span class="anchor" id="line-56"></span>    'X-Habeas-SWE-2' : 'brightly anticipated',
<span class="anchor" id="line-57"></span>    'X-Habeas-SWE-3' : 'like Habeas SWE (tm)',
<span class="anchor" id="line-58"></span>    'X-Habeas-SWE-4' : 'Copyright 2002 Habeas (tm)',
<span class="anchor" id="line-59"></span>    'X-Habeas-SWE-5' : 'Sender Warranted Email (SWE) (tm). The sender of this',
<span class="anchor" id="line-60"></span>    'X-Habeas-SWE-6' : 'email in exchange for a license for this Habeas',
<span class="anchor" id="line-61"></span>    'X-Habeas-SWE-7' : 'warrant mark warrants that this is a Habeas Compliant',
<span class="anchor" id="line-62"></span>    'X-Habeas-SWE-8' : 'Message (HCM) and not spam. Please report use of this',
<span class="anchor" id="line-63"></span>    'X-Habeas-SWE-9' : 'mark in spam to &lt;http://www.habeas.com/report/&gt;.'
<span class="anchor" id="line-64"></span>    }
<span class="anchor" id="line-65"></span>ADDED_HEADERS_SERVER = ADDED_HEADERS_CLIENT
<span class="anchor" id="line-66"></span></pre><span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><p class="line867">
<h2 id="head-1166fa525e5050c978c370da72a6c5f29e4bacca">Rotating TMDA logs</h2>
<span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line874">Here are some tips for rotating your TMDA logs. <span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><p class="line874">Here's a solution that should work everywhere TMDA does, but grows indefinitely in size because old logs are never deleted. Add the following to your .tmda/conf file: <span class="anchor" id="line-73"></span><span class="anchor" id="line-74"></span><p class="line867"><span class="anchor" id="line-75"></span><pre>import os, time
<span class="anchor" id="line-76"></span>homedir = os.path.expanduser("~")
<span class="anchor" id="line-77"></span>YYYYmm = time.strftime("%Y-%m")         # 2001-04
<span class="anchor" id="line-78"></span>
<span class="anchor" id="line-79"></span>LOGFILE_DEBUG = os.path.join(homedir, "log/tmda", "debug." + YYYYmm)
<span class="anchor" id="line-80"></span>LOGFILE_INCOMING = os.path.join(homedir, "log/tmda", "incoming." + YYYYmm)
<span class="anchor" id="line-81"></span></pre><span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><p class="line874">The end result looks like this: <span class="anchor" id="line-84"></span><span class="anchor" id="line-85"></span><pre>-rw-------  1 jason  wheel  1101449 Dec 31 23:58 incoming.2002-12
<span class="anchor" id="line-86"></span>-rw-------  1 jason  wheel  1394177 Jan 31 22:51 incoming.2003-01
<span class="anchor" id="line-87"></span>-rw-------  1 jason  wheel  1172741 Feb 24 13:47 incoming.2003-02
<span class="anchor" id="line-88"></span></pre><span class="anchor" id="line-89"></span><span class="anchor" id="line-90"></span><p class="line874">Here's a more powerful log rotation scheme that is specific to FreeBSD. Something similar should work on Linux using the "logrotate" program. <span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span><p class="line874">1. Create your own "newsyslog.conf" configuration file. In my case, I made it: <span class="anchor" id="line-93"></span><span class="anchor" id="line-94"></span><ul><li style="list-style-type:none">/home/mark/etc/newsyslog.conf <span class="anchor" id="line-95"></span><span class="anchor" id="line-96"></span></li></ul><p class="line874">The contents look like this: <span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><pre># logfilename              mode count size when [ZB]
<span class="anchor" id="line-99"></span>/home/mark/.tmda/log-in    600  3     100  *     Z
<span class="anchor" id="line-100"></span>/home/mark/.tmda/log-out   600  3     100  *     Z
<span class="anchor" id="line-101"></span></pre><span class="anchor" id="line-102"></span><p class="line874">2. Then I created a cron entry to run every hour, using "crontab -e" to edit my personal crontab file: <span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><pre># Rotate TMDA logs
<span class="anchor" id="line-105"></span>13 * * * * newsyslog -r -f /home/mark/etc/newsyslog.conf
<span class="anchor" id="line-106"></span></pre><span class="anchor" id="line-107"></span><p class="line874">If you have other personal log files you want to rotate, you can simply add entries to you personal "newsyslog.conf" file for them. <span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><p class="line874">Here's one way to use logrotate on linux: <span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><p class="line874">1. Set up your configuration file. <span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><p class="line874">I put mine in <span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><p class="line867"><span class="anchor" id="line-116"></span><pre>
<span class="anchor" id="line-117"></span> /home/monique/.logrotate.conf
<span class="anchor" id="line-118"></span>
<span class="anchor" id="line-119"></span></pre><span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line874">Here's an example configuration. Use the same format for the debug and outgoing logs. <span class="anchor" id="line-122"></span><span class="anchor" id="line-123"></span><p class="line867"><span class="anchor" id="line-124"></span><pre>
<span class="anchor" id="line-125"></span># global: create new (empty) log files after rotating old ones create
<span class="anchor" id="line-126"></span>
<span class="anchor" id="line-127"></span></pre><span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><p class="line867"><span class="anchor" id="line-130"></span><pre># rotates log into a gzipped file every week.
<span class="anchor" id="line-131"></span># logs from the most recent five weeks are kept;
<span class="anchor" id="line-132"></span># older ones are purged.
<span class="anchor" id="line-133"></span>/home/monique/log/tmda/incoming {
<span class="anchor" id="line-134"></span>   weekly
<span class="anchor" id="line-135"></span>   rotate 5
<span class="anchor" id="line-136"></span>   compress
<span class="anchor" id="line-137"></span>} </pre><span class="anchor" id="line-138"></span><span class="anchor" id="line-139"></span><p class="line874">2. Create a logrotate state file specific to your user. The logrotate program will populate it for you. This will contain a list of the log files you're rotating and the date they were last checked. <span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><p class="line867"><span class="anchor" id="line-142"></span><pre>touch /home/monique/log/logrotate.state</pre><span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line862">3. Use <tt class="backtick">crontab&nbsp;-e</tt> to schedule logrotate <span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><p class="line867"><span class="anchor" id="line-147"></span><pre>@daily /usr/sbin/logrotate --state /home/monique/log/logrotate.state   /home/monique/.logrotate.conf</pre><span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line874">Once the cron job has run, you should see something similar to this: <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line867"><span class="anchor" id="line-152"></span><pre>monique-home:~$ ls log/tmda/
<span class="anchor" id="line-153"></span>debug  debug.1.gz  incoming  incoming.1.gz  outgoing  outgoing.1.gz</pre><span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line867">
<h2 id="head-02d10a9b3f486744662ad22509f12cbdc1269be2">Blocking SPAM where sender equals recipient (Exim 4.x)</h2>
<span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line874">The Exim SMTP server introduced ACL's (Access Control Lists) in version 4.x. These provide a very flexible way to control, and conditionally reject, unwanted mail and/or SMTP communications. Exim ACL's can check all stages of the SMTP session, for example - connect, auth, data and the one we will use here - rcpt (recipient). <span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line874">This simple ACL allows the blocking of emails where the sender address is the same as the recipient address, a trick used by spammers to get past filters. The logic checks if the sending address is the same as the recipient address and the sending host IP address is not in the list of allowed relaying hosts. In a simple MTA installation the "relay_from_hosts" will usually just include the internal non-Internet routable address block and localhost. <span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line874">The "relay_from_hosts" entry is defined in the main section of the Exim configuration file. <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><pre># Main Section:
<span class="anchor" id="line-164"></span>
<span class="anchor" id="line-165"></span>hostlist relay_from_hosts = 192.168.1.0/24 : 127.0.0.1
<span class="anchor" id="line-166"></span></pre><span class="anchor" id="line-167"></span><p class="line874">The ACL is placed in the "acl_check_rcpt" part of the ACL section of the config file. The condition uses regular expressions to return true if the sender address = recipient address then checks if the sender's host IP address is not in the list of allowed relay hosts. <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><pre># ACL Section:
<span class="anchor" id="line-170"></span>
<span class="anchor" id="line-171"></span>acl_check_rcpt:
<span class="anchor" id="line-172"></span>
<span class="anchor" id="line-173"></span># Block spoofed addresses
<span class="anchor" id="line-174"></span>
<span class="anchor" id="line-175"></span>  deny  condition       = ${if eq {$sender_address}{$local_part@$domain}{yes}{no}}
<span class="anchor" id="line-176"></span>        hosts           = !+relay_from_hosts
<span class="anchor" id="line-177"></span>        message         = Spammers not welcome - go away.
<span class="anchor" id="line-178"></span>        log_message     = Spam from sender $sender_address at $sender_fullhost
<span class="anchor" id="line-179"></span></pre><span class="anchor" id="line-180"></span><p class="line874">The condition can also be changed to check addresses on the domain level if you know that addresses coming into the mail domain from the outside should never have the internal mail domain as their sending domain. <span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span><pre>${if eq {$sender_address_domain}{$domain}{yes}{no}}
<span class="anchor" id="line-183"></span></pre><span class="anchor" id="line-184"></span><p class="line874">If the condition is true the ACL will reject the RCPT with a 550 permanent error. You can define different messages to be returned to the sender and written to the Exim log files. <span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span><p class="line867">
<h2 id="head-954538db8b8b61ea673bf045a777d57e9e14842e">Using SMTP server instead of tmda-ofmipd for non-Unix MUAs mail sending (Exim 4.x)</h2>
<span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span><p class="line874">Introduction <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line874">If you have Windows OS client MUA's and you want to take advantage of TMDA's outgoing tagging features without having the extra setup of tmda-ofmipd - <span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><ol type="1"><li>need to have extra tofmipd daemon running on Unix/Linux server <span class="anchor" id="line-193"></span></li><li>need to setup authenticated accounts for tofmipd on Unix/Linux server <span class="anchor" id="line-194"></span></li><li>changing the SMTP port and authentication configuration on each client machine <span class="anchor" id="line-195"></span><span class="anchor" id="line-196"></span></li></ol><p class="line874">- this can be achieved if your MTA is Exim 4.x by having Exim work directly with the tmda-inject module. <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span><p class="line874">Setup <span class="anchor" id="line-199"></span><span class="anchor" id="line-200"></span><p class="line874">The tmda-sendmail and tmda-ofmipd modules both call tmda-inject which does the work of checking user's tmda settings, including whitelist files, before rewriting the sending email address if necessary. The method described below has Exim cycle outgoing mail directly through tmda-inject which then sends it back to Exim for final delivery. <span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><p class="line874">Exim uses "routers" to decide on delivery path for email and "transports" to physically deliver mail to the next stage of the mail handling process. The order in which routers are processed is important, as the first router to match an email address will process the email. As we want to 'catch' any outgoing emails and send them to tmda-inject before they are processed by the usual outgoing router (dnslookup) we place the new router called 'outgoing_tmda' before the 'dnslookup' router. The router is: <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><pre># Outgoing tmda router - sends all first run of outgoing mail for tmda users to tmda
<span class="anchor" id="line-205"></span>outgoing_tmda:
<span class="anchor" id="line-206"></span>    driver = accept
<span class="anchor" id="line-207"></span>    senders = name@domainname.com : name2@domainname.com : etc....
<span class="anchor" id="line-208"></span>    domains = !+local_domains
<span class="anchor" id="line-209"></span>    condition = "${if !def:header_X-Delivery-Agent:{1}{0}}"
<span class="anchor" id="line-210"></span>    transport = outgoing_tmda_pipe
<span class="anchor" id="line-211"></span></pre><span class="anchor" id="line-212"></span><p class="line874">The details are: <span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span><ul><li>driver - basically says accept the email if the conditions are met. Other driver types for Exim transports can be - redirect, dnslookup etc. <span class="anchor" id="line-215"></span></li><li>senders - the plain email address of the sender i.e. before tagging by tmda. The senders lookup can be anything supported by Exim - a colon separated list (adequate for small sites) all the way up to an SQL database lookup. This is necessary for situations where you may have a site with tmda and non-tmda users. <span class="anchor" id="line-216"></span></li><li>domains - "!+local_domains" means where destination domains is not inside domain <span class="anchor" id="line-217"></span></li><li>condition - looks to see if the tmda header "X-Delivery-Agent:" is not present in the mail headers. This will be the case on the first pass of the mail message through Exim. Note the double quotes around the condition. <span class="anchor" id="line-218"></span></li><li>transport = says which physical transport will handle the email <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span></li></ul><p class="line874">Then the mail will go to the defined transport "outgoing_tmda_pipe". The key consideration with the transport is that it must be setup to function in the context of the user sending out the email. If the context does not match the user it will not work. Now this may differ in various sites so I will list my environment - <span class="anchor" id="line-221"></span><span class="anchor" id="line-222"></span><ul><li>Redhat 7.x; <span class="anchor" id="line-223"></span></li><li>Python 2.x installed on top of default Python 1.5 installed by Redhat 7.x; <span class="anchor" id="line-224"></span></li><li>user directories under /home; <span class="anchor" id="line-225"></span></li><li>user's tmda settings and crypt key in /home/user/.tmda; <span class="anchor" id="line-226"></span></li><li>all users using tmda added to OS group 'tmda'. <span class="anchor" id="line-227"></span><span class="anchor" id="line-228"></span></li></ul><p class="line874">To ensure that the message is not expanded resulting in multiple deliveries where there are multiple recipients you must use Exim's batching facility (see "Address batching in local transports" in Exim spec document) as is shown in the transport below. <span class="anchor" id="line-229"></span><span class="anchor" id="line-230"></span><pre># Outgoing tmda transport - pipes email in batch to tmda-inject
<span class="anchor" id="line-231"></span>outgoing_tmda_pipe:
<span class="anchor" id="line-232"></span>    driver = pipe
<span class="anchor" id="line-233"></span>    batch_max = 1000
<span class="anchor" id="line-234"></span>    home_directory = /home/$sender_address_local_part
<span class="anchor" id="line-235"></span>    command = /usr/bin/python2 /usr/bin/tmda-inject $pipe_addresses
<span class="anchor" id="line-236"></span>    user = $sender_address_local_part
<span class="anchor" id="line-237"></span>    group = tmda
<span class="anchor" id="line-238"></span></pre><span class="anchor" id="line-239"></span><p class="line874">The details are: <span class="anchor" id="line-240"></span><span class="anchor" id="line-241"></span><ul><li>driver - pipe command obviously! <span class="anchor" id="line-242"></span></li><li>batch_max = 1000 - as we piping the email to tmda we don't want Exim to run multiple instances of  the transport for each address otherwise the message will be sent x n for n recipients. <span class="anchor" id="line-243"></span></li><li>home_directory - /home/ + Exim expansion variable which is the local part (before the @ sign) of the sending email address. <span class="anchor" id="line-244"></span></li><li>command - the python2 executable is specified, the tmda command is tmda-inject, the Exim variable $pipe_addresses tells Exim that this email is being piped, not actually finally delivered, so batch all recipient addresses. <span class="anchor" id="line-245"></span></li><li><p class="line862">user - which will be the OS user, taken again from the local part of the user address. Obviously this must match, so if the sending address is - <a class="mailto" href="mailto:fred@bloggs.com">fred@bloggs.com</a> then the OS user name must be 'fred'. <span class="anchor" id="line-246"></span></li><li>group - OS group for all tmda users. <span class="anchor" id="line-247"></span><span class="anchor" id="line-248"></span></li></ul><p class="line874">Testing <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line874">You should test the functioning of this before going live, I recommend doing a debug test first to follow through the processing of the email then do a live test. Exim provides many command line testing options (see Exim spec.txt), you need the following command: <span class="anchor" id="line-251"></span><span class="anchor" id="line-252"></span><pre>[root@server bin]# ./exim -d -bs
<span class="anchor" id="line-253"></span></pre><span class="anchor" id="line-254"></span><p class="line874">type in the SMTP commands manually - internal sender, external recipient and a simple data line then quit. Things to check: <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><ol type="1"><li>The router accepts the email and sends to correct transport <span class="anchor" id="line-257"></span></li><li>The uid/gid is changed to sending user before calling pipe command <span class="anchor" id="line-258"></span></li><li>The tmda-inject program accepts the email successfully - "outgoing_tmda_pipe transport yielded 0" <span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span></li></ol><p class="line874">In the debug output you should see something like this: <span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><pre>    outgoing_tmda_pipe transport returned OK for recipient@domain.com
<span class="anchor" id="line-263"></span>    post-process recipient@domain.com (0)
<span class="anchor" id="line-264"></span>    recipient@domain.com delivered
<span class="anchor" id="line-265"></span>    LOG: MAIN
<span class="anchor" id="line-266"></span>     =&gt; recipient &lt;recipient@domain.com&gt; R=outgoing_tmda T=outgoing_tmda_pipe
<span class="anchor" id="line-267"></span></pre><span class="anchor" id="line-268"></span><p class="line874">Then you can run a full test, if you are using Eximon you can watch the results live. One thing which may confuse you - you will see 'incoming' messages first then the various 'outgoing' messages. Just refer to the message ID's to see the flow. If the recipient is not on your whitelist you will (depending on your tmda setup) see your email address be transformed from your bare address to your tmda tagged address - in my case a14d dated address. <span class="anchor" id="line-269"></span><span class="anchor" id="line-270"></span><p class="line867">
<h2 id="head-8fc28dccfdc0368d450108a014e457a319afc462">How to improve performance (for high volume sites)</h2>
<span class="anchor" id="line-271"></span><span class="anchor" id="line-272"></span><p class="line874">TMDA generally performs adequately, but high volume sites might need to tune their configurations according to the suggestions below. This particular list was written for an ISP which processes ~50,000 messages/day with TMDA. Even if you don't run a high volume installation, you may find one or more of these suggestions helpful. <span class="anchor" id="line-273"></span><span class="anchor" id="line-274"></span><p class="line874">This list assumes that the reader is already familiar with TMDA and how it works. <span class="anchor" id="line-275"></span><span class="anchor" id="line-276"></span><ol type="1"><li>Avoid doing content filtering via 'headers' and 'body' rules. If you need to do content filtering, use another tool which is more optimized for this task such as maildrop. <span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span></li><li class="gap">Upgrade your Python to the latest available release (2.5 at current writing). Besides being more stable, Python 2.5 can be up to 30% faster than previous versions of Python. <span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span></li><li class="gap">Upgrade your TMDA to the latest available release (1.1.x at current writing). TMDA's performance is constantly improving. <span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span></li><li class="gap">Set CONFIRM_ACCEPT_NOTIFY = False in /etc/tmdarc to greatly reduce the number of messages TMDA sends out. <span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span></li><li class="gap"><p class="line862">Don't use any wildcards (e.g, *@foo.com) in your list files, but only plain e-mail addresses (e.g, <a class="mailto" href="mailto:jason@foo.com">jason@foo.com</a>) or domains (e.g, foo.com, mail.foo.com). The wildcard code is very expensive and isn't compatible with -autocdb or -autodbm. In most cases you can accomplish what you want using plain domains anyway. <span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span></li><li class="gap">Use -autocdb or -autodbm with all flat file lists. -autocdb is probably better, but requires you install the python-cdb extension module. -autodbm works out of the box. <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span></li><li class="gap">Disable all logging if you have it enabled (TMDA does no logging by default). <span class="anchor" id="line-289"></span><span class="anchor" id="line-290"></span></li><li class="gap">If you are really looking to optimize, consider setting values in /etc/tmdarc for TMDA variables whose defaults are "expensive" to calculate. The best way to do this is to page through the TMDA/Defaults.py file and look at how the various default values are calculated. Some have negligable expense, others not. For example, `SENDMAIL_PROGRAM' is a good one to hardcode as it saves at least one stat() for each incoming message.  <span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span></li></ol><p class="line867">
<h2 id="head-c6f1707b95c5e8674235e942cc5beef89533865b">X-TMDA: and Mozilla Thunderbird</h2>
<span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><p class="line874">Now you too can add an X-TMDA to Mozilla Thunderbird on a per-message basis, just like the pros: <span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><ol type="1"><li>Find and edit your user.js file in your profile, and add the following line: <span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span><pre>user_pref("mail.compose.other.header", "X-TMDA");</pre><span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span></li><li class="gap">Shutdown Thunderbird and restart it. The next time you compose an email and want to add an X-TMDA header, click on a new line in the recipient area, and click on the down-arrow beside "To". Choose "X-TMDA" and put in the setting you need. <span class="anchor" id="line-301"></span></li></ol><span class="anchor" id="bottom"></span></div>
</div>
<hr>
2007-07-30 15:45
</body>
</html>
